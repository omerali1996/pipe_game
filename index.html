<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pipe Chaos - Boru Bulmaca Oyunu</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f35 100%);
      color: #e0e6f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      padding: 20px;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 10px;
      color: #4da3ff;
      text-align: center;
    }

    .top-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 15px;
    }

    .info {
      background-color: #222b45;
      padding: 8px 16px;
      border-radius: 10px;
      font-size: 0.9rem;
    }

    .buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    button {
      background-color: #4da3ff;
      border: none;
      padding: 10px 18px;
      color: #fff;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #398ae3;
    }

    #gameGrid {
      display: grid;
      gap: 3px;
      background-color: #1f253a;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
    }

    .cell {
      background-color: #eef2f7;
      border: 1px solid #ccd2dc;
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cell canvas {
      width: 60px;
      height: 60px;
    }

    footer {
      margin-top: 30px;
      font-size: 0.8rem;
      color: #aaa;
    }
  </style>
</head>
<body>
  <h1>Pipe Chaos ðŸ’§</h1>

  <div class="top-bar">
    <div class="info">Seviye: <span id="levelName">BaÅŸlangÄ±Ã§</span></div>
    <div class="info">Kalan Hamle: <span id="movesValue">0</span></div>
    <div class="info">Puan: <span id="scoreValue">0</span></div>
  </div>

  <div class="buttons">
    <button id="startBtn">AkÄ±ÅŸÄ± BaÅŸlat</button>
    <button id="resetBtn">SÄ±fÄ±rla</button>
  </div>

  <div id="gameGrid"></div>

  <footer>Â© 2025 Pipe Chaos - TÃ¼m haklarÄ± saklÄ±dÄ±r.</footer>

  <script>
    // =============================
    // PIPE CHAOS - FIXED EDITION
    // =============================

    const PIPE_TYPES = {
      STRAIGHT_V: 'straight_v',
      STRAIGHT_H: 'straight_h',
      CORNER_TR: 'corner_tr',
      CORNER_TL: 'corner_tl',
      CORNER_BR: 'corner_br',
      CORNER_BL: 'corner_bl',
      START: 'start',
      TARGET: 'target',
      BLOCKED: 'blocked'
    };

    const LEVELS = [
      { grid: 5, straights: 6, corners: 4, moves: 20, blocked: 0, name: 'BaÅŸlangÄ±Ã§' },
      { grid: 6, straights: 7, corners: 5, moves: 18, blocked: 2, name: 'Kolay' },
      { grid: 7, straights: 8, corners: 6, moves: 16, blocked: 4, name: 'Orta' },
      { grid: 7, straights: 9, corners: 7, moves: 14, blocked: 6, name: 'Zor' },
      { grid: 8, straights: 10, corners: 8, moves: 12, blocked: 8, name: 'Uzman' }
    ];

    class PipeChaosGame {
      constructor() {
        this.level = 0;
        this.score = 0;
        this.movesLeft = 0;
        this.gridSize = 5;
        this.cells = [];
        this.selectedPipe = null;

        this.initElements();
        this.initEventListeners();
        this.initLevel();
      }

      initElements() {
        this.gameGrid = document.getElementById('gameGrid');
        this.levelName = document.getElementById('levelName');
        this.movesValue = document.getElementById('movesValue');
        this.scoreValue = document.getElementById('scoreValue');
      }

      initEventListeners() {
        document.getElementById('startBtn').addEventListener('click', () => this.startFlow());
        document.getElementById('resetBtn').addEventListener('click', () => this.initLevel());
      }

      initLevel() {
        const config = LEVELS[this.level];
        this.gridSize = config.grid;
        this.movesLeft = config.moves;
        this.movesValue.textContent = config.moves;
        this.levelName.textContent = config.name;

        this.gameGrid.innerHTML = '';
        this.gameGrid.style.gridTemplateColumns = `repeat(${this.gridSize}, 60px)`;
        this.gameGrid.style.gridTemplateRows = `repeat(${this.gridSize}, 60px)`;
        this.cells = [];

        for (let r = 0; r < this.gridSize; r++) {
          const row = [];
          for (let c = 0; c < this.gridSize; c++) {
            const cell = this.createCell(r, c);
            this.gameGrid.appendChild(cell.element);
            row.push(cell);
          }
          this.cells.push(row);
        }
      }

      createCell(row, col) {
        const cell = {
          row,
          col,
          placed: false,
          type: null,
          fixed: false,
          element: document.createElement('div'),
          canvas: document.createElement('canvas')
        };
        cell.element.className = 'cell';
        cell.canvas.width = 60;
        cell.canvas.height = 60;
        cell.element.appendChild(cell.canvas);

        if (row === 0 && col === 0) {
          cell.placed = true;
          cell.type = PIPE_TYPES.START;
          cell.fixed = true;
        } else if (row === this.gridSize - 1 && col === this.gridSize - 1) {
          cell.placed = true;
          cell.type = PIPE_TYPES.TARGET;
          cell.fixed = true;
        }

        cell.element.addEventListener('click', () => this.onCellClick(cell));
        cell.element.addEventListener('dblclick', () => this.onCellDoubleClick(cell));

        this.drawCell(cell);
        return cell;
      }

      onCellClick(cell) {
        if (cell.fixed) return;
        const types = Object.values(PIPE_TYPES).filter(
          (t) => t !== PIPE_TYPES.START && t !== PIPE_TYPES.TARGET
        );
        const randomType = types[Math.floor(Math.random() * types.length)];
        cell.type = randomType;
        cell.placed = true;
        this.drawCell(cell);
      }

      onCellDoubleClick(cell) {
        if (cell.fixed) return;
        if (cell.placed) {
          cell.type = this.rotatePipeType(cell.type);
          this.drawCell(cell);
        }
      }

      rotatePipeType(type) {
        const map = {
          [PIPE_TYPES.STRAIGHT_V]: PIPE_TYPES.STRAIGHT_H,
          [PIPE_TYPES.STRAIGHT_H]: PIPE_TYPES.STRAIGHT_V,
          [PIPE_TYPES.CORNER_TR]: PIPE_TYPES.CORNER_BR,
          [PIPE_TYPES.CORNER_BR]: PIPE_TYPES.CORNER_BL,
          [PIPE_TYPES.CORNER_BL]: PIPE_TYPES.CORNER_TL,
          [PIPE_TYPES.CORNER_TL]: PIPE_TYPES.CORNER_TR
        };
        return map[type] || type;
      }

      drawCell(cell) {
        const ctx = cell.canvas.getContext('2d');
        ctx.clearRect(0, 0, 60, 60);

        if (cell.type === PIPE_TYPES.START) {
          ctx.fillStyle = '#4da3ff';
          ctx.beginPath();
          ctx.arc(30, 30, 10, 0, Math.PI * 2);
          ctx.fill();
          return;
        }
        if (cell.type === PIPE_TYPES.TARGET) {
          ctx.fillStyle = '#f4d03f';
          ctx.beginPath();
          ctx.arc(30, 30, 10, 0, Math.PI * 2);
          ctx.fill();
          return;
        }
        if (cell.placed) this.drawPipe(ctx, cell.type);
      }

      drawPipe(ctx, type) {
        ctx.strokeStyle = '#404852';
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.beginPath();
        const cx = 30, cy = 30;

        switch (type) {
          case PIPE_TYPES.STRAIGHT_V:
            ctx.moveTo(cx, 5);
            ctx.lineTo(cx, 55);
            break;
          case PIPE_TYPES.STRAIGHT_H:
            ctx.moveTo(5, cy);
            ctx.lineTo(55, cy);
            break;
          case PIPE_TYPES.CORNER_TR:
            ctx.moveTo(cx, 55);
            ctx.lineTo(cx, cy);
            ctx.lineTo(55, cy);
            break;
          case PIPE_TYPES.CORNER_TL:
            ctx.moveTo(cx, 55);
            ctx.lineTo(cx, cy);
            ctx.lineTo(5, cy);
            break;
          case PIPE_TYPES.CORNER_BR:
            ctx.moveTo(cx, 5);
            ctx.lineTo(cx, cy);
            ctx.lineTo(55, cy);
            break;
          case PIPE_TYPES.CORNER_BL:
            ctx.moveTo(cx, 5);
            ctx.lineTo(cx, cy);
            ctx.lineTo(5, cy);
            break;
        }

        ctx.stroke();

        ctx.fillStyle = '#aab7cf';
        ctx.beginPath();
        ctx.arc(cx, cy, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      startFlow() {
        alert('AkÄ±ÅŸ simÃ¼lasyonu sonraki sÃ¼rÃ¼mde aktif olacak ðŸ’§');
      }
    }

    window.addEventListener('DOMContentLoaded', () => new PipeChaosGame());
  </script>
</body>
</html>
